# Система масштабирования текста и UI элементов (Grid Snapping)

**Версия:** 1.0  
**Дата создания:** 2026-01-27  
**Статус:** Актуально

Документ описывает детали реализации позиционирования элементов внутри модальных окон (Grid Snapping) и специфику масштабирования текста для обеспечения четкости (pixel-perfect) и корректных переносов строк.

---

## 1. Grid Snapping (Привязка к пиксельной сетке)

### Концепция
Все элементы интерфейса (модальные окна, кнопки, иконки) должны быть выровнены по виртуальной пиксельной сетке, определяемой `BASE_SCALE`.

**Константы:**
- `BASE_SCALE = 4.0` (масштаб игрового мира и UI относительно исходных ассетов)
- **Шаг сетки:** 4 виртуальных пикселя (1 исходный пиксель).
- **Шаг центрирования:** 8 виртуальных пикселей (2 исходных пикселя), чтобы центрированные элементы (деление на 2) также попадали в сетку.

### Реализация
В `KeyQuestionModal.ts` (и других UI компонентах) используются вспомогательные функции:

```typescript
// Округление до ближайшего целого пикселя исходного разрешения (шаг 4)
const snapToGrid = (val: number) => Math.round(val / BASE_SCALE) * BASE_SCALE;

// Округление до 2-х пикселей (шаг 8), для корректного центрирования
const snapToGridDouble = (val: number) => Math.round(val / (BASE_SCALE * 2)) * (BASE_SCALE * 2);
```

### Применение для Кнопки Закрытия
Для идеального позиционирования кнопки закрытия:
1. Размеры модального окна (`modalWidth`, `modalHeight`) округляются через `snapToGridDouble` (кратны 8).
2. Координаты модального окна (`modalX`, `modalY`) округляются через `snapToGrid` (кратны 4).
3. Размер кнопки закрытия также кратен 4 (например, 14 * 4 = 56).
4. **Результат:** Формула `modalX + modalWidth / 2 - closeSize / 2` гарантированно дает целое число, кратное 4.

**Ассет кнопки закрытия:** `UI.DialogClose_14x14.png` (без внутренних отступов).

---

## 2. Масштабирование Текста (Text Scaling)

### Проблема размытия
При масштабировании canvas браузером или зуме камеры стандартный текст Phaser может размываться.

### Решение: Pixel-Perfect Rendering
1. Текстовые объекты создаются с `fontSize`, рассчитанным для конкретного контейнера.
2. Применяется **компенсация зума**:
   ```typescript
   textObj.setScale(1 / camera.zoom);
   ```
   Это делает текст визуально одинакового размера на экране, но рендерит его в высоком разрешении, соответствующем зуму.
3. Устанавливается `setResolution(textResolution)` (обычно > 1) для повышения плотности пикселей.

---

## 3. Перенос строк в Кнопках (Button WordWrap)

### Проблема
Текст внутри кнопок (`Button.ts`) масштабируется через `setScale(1 / zoom)`. Однако, свойство `wordWrap.width` в Phaser применяется к *немасштабированному* тексту (до применения scale).
Если установить `wordWrap: { width: buttonWidth }`, то при зуме `0.5` текст увеличится в 2 раза (`scale=2`), и визуально строка станет в 2 раза длиннее, вылезая за границы `wordWrap` (который остался прежним).

### Решение
Ширина переноса должна быть **умножена на зум**, чтобы компенсировать обратное масштабирование текста.

**В файле `Button.ts`:**
```typescript
const zoom = this.scene.cameras.main.zoom;
const wordWrapWidth = (this.width * 0.95) * zoom; // 0.95 - коэффициент безопасности

// Применение
this.text = this.scene.add.text(..., {
   wordWrap: { width: wordWrapWidth, useAdvancedWrap: true }
});
this.text.setScale(1 / zoom); // Компенсация зума для размера
```

### Коэффициент безопасности
Используется коэффициент **0.95** (5% отступа) для гарантии того, что текст не будет касаться краев кнопки даже при незначительных погрешностях рендеринга шрифта.

---

## 4. Обновление Ассетов UI

### Кнопка Закрытия
- **Файл:** `UI.DialogClose_14x14.png`
- **Размер:** 14x14 пикселей (исходный).
- **Особенности:** Текстура занимает всю площадь, без прозрачных полей. Это позволяет использовать чистое математическое позиционирование без ручных смещений ("magic numbers").

### Конфигурация (`spritesheetConfigs.ts`)
```typescript
{
  load: {
    key: 'ui_dialog_close',
    path: 'UI.DialogClose_14x14.png',
    frameWidth: 14,
    frameHeight: 14,
    // ...
  }
}
```
